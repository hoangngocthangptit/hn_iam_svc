import BaseEntityChangesGenerator from '../base-entity-changes/index.js';
import type { Field } from '../../lib/types/application/index.js';
export default class LiquibaseGenerator extends BaseEntityChangesGenerator {
    [BaseEntityChangesGenerator.PREPARING]: any;
    [BaseEntityChangesGenerator.PREPARING_EACH_ENTITY_FIELD]: any;
    [BaseEntityChangesGenerator.PREPARING_EACH_ENTITY_RELATIONSHIP]: any;
    [BaseEntityChangesGenerator.POST_PREPARING_EACH_ENTITY]: import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/application/tasks.js").PreparingEachEntityTaskParam<import("../../lib/types/application/entity.js").Entity<Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../../lib/types/application/entity.js").Entity<Field, never>>>, "postPrepareEntity">;
    [BaseEntityChangesGenerator.DEFAULT]: any;
    [BaseEntityChangesGenerator.WRITING]: any;
    [BaseEntityChangesGenerator.WRITING_ENTITIES]: any;
    [BaseEntityChangesGenerator.POST_WRITING]: any;
    [BaseEntityChangesGenerator.POST_WRITING_ENTITIES]: any;
    recreateInitialChangelog: boolean;
    numberOfRows: number;
    databaseChangelogs: any[];
    injectBuildTool: boolean;
    injectLogs: boolean;
    constructor(args: any, options: any, features: any);
    beforeQueue(): Promise<void>;
    get preparing(): import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/application/tasks.js").PreparingTaskParam<import("../../lib/types/application/entity.js").Entity<Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../../lib/types/application/entity.js").Entity<Field, never>>>, "preparing" | "addNeedles" | "checkDatabaseCompatibility">;
    get preparingEachEntityField(): import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/application/tasks.js").PreparingEachEntityFieldTaskParam<import("../../lib/types/application/entity.js").Entity<Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../../lib/types/application/entity.js").Entity<Field, never>>>, "prepareEntityField" | "validateConsistencyOfField">;
    get preparingEachEntityRelationship(): import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/application/tasks.js").PreparingEachEntityRelationshipTaskParam<import("../../lib/types/application/entity.js").Entity<Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../../lib/types/application/entity.js").Entity<Field, never>>>, "prepareEntityRelationship">;
    get postPreparingEachEntity(): import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/application/tasks.js").PreparingEachEntityTaskParam<import("../../lib/types/application/entity.js").Entity<Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../../lib/types/application/entity.js").Entity<Field, never>>>, "postPrepareEntity">;
    get default(): import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/base/tasks.js").TaskParamWithControl & {
        application: import("../../lib/types/application/application.js").ApplicationType<import("../../lib/types/application/entity.js").Entity<Field, never>>;
    } & {
        entities: import("../../lib/types/application/entity.js").Entity<Field, never>[];
    } & {
        entityChanges?: import("../base-entity-changes/types.js").BaseChangelog[];
    }, "calculateChangelogs">;
    get writing(): import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/application/tasks.js").WritingTaskParam<import("../../lib/types/application/entity.js").Entity<Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../../lib/types/application/entity.js").Entity<Field, never>>>, "writing">;
    get writingEntities(): import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/base/tasks.js").TaskParamWithControl & {
        application: import("../../lib/types/application/application.js").ApplicationType<import("../../lib/types/application/entity.js").Entity<Field, never>>;
    } & {
        entities: import("../../lib/types/application/entity.js").Entity<Field, never>[];
    } & {
        entityChanges?: import("../base-entity-changes/types.js").BaseChangelog[];
    }, "writeChangelogs">;
    get postWriting(): import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/application/tasks.js").PostWritingTaskParam<import("../../lib/types/application/entity.js").Entity<Field, never>, import("../../lib/types/application/application.js").ApplicationType<import("../../lib/types/application/entity.js").Entity<Field, never>>>, "customizeMaven" | "nativeHints" | "customizeSpringLogs" | "customizeApplicationProperties" | "injectGradle">;
    get postWritingEntities(): import("../../lib/types/base/tasks.js").GenericTaskGroup<any, import("../../lib/types/base/tasks.js").TaskParamWithControl & {
        application: import("../../lib/types/application/application.js").ApplicationType<import("../../lib/types/application/entity.js").Entity<Field, never>>;
    } & {
        entities: import("../../lib/types/application/entity.js").Entity<Field, never>[];
    } & {
        source: import("../../lib/types/application/application.js").BaseApplicationSource;
    } & {
        entityChanges?: import("../base-entity-changes/types.js").BaseChangelog[];
    }, "postWriteChangelogs">;
    isChangelogNew({ entityName, changelogDate }: {
        entityName: any;
        changelogDate: any;
    }): boolean;
    /**
     * Write files for new entities.
     */
    _writeLiquibaseFiles({ context: writeContext, changelogData }: {
        context: any;
        changelogData: any;
    }): Promise<any[]>;
    /**
     * Write files for new entities.
     */
    _addLiquibaseFilesReferences({ entity, databaseChangelog, source }: {
        entity: any;
        databaseChangelog: any;
        source: any;
    }): void;
    /**
     * Write files for updated entities.
     */
    _writeUpdateFiles({ context: writeContext, changelogData }: {
        context: any;
        changelogData: any;
    }): Promise<any[]>;
    private _requiresConstraintUpdates;
    private _isBasicEntityUpdate;
    private _requiresWritingFakeData;
    /**
     * Write files for updated entities.
     */
    _addUpdateFilesReferences({ entity, databaseChangelog, changelogData, source }: {
        entity: any;
        databaseChangelog: any;
        changelogData: any;
        source: any;
    }): void;
    /**
     * @private
     * Format As Liquibase Remarks
     *
     * @param {string} text - text to format
     * @param {boolean} addRemarksTag - add remarks tag
     * @returns formatted liquibase remarks
     */
    formatAsLiquibaseRemarks(text: any, addRemarksTag?: boolean): any;
    /**
     * @private
     * Create the fitting liquibase default value attribute for a field.
     * @param field
     * @param leadingWhitespace
     * @returns
     */
    createDefaultValueLiquibaseAttribute(field: Field, leadingWhitespace?: boolean): string;
    prepareChangelog({ databaseChangelog, application }: {
        databaseChangelog: any;
        application: any;
    }): any;
    writeChangelog({ databaseChangelog }: {
        databaseChangelog: any;
    }): Promise<any[]> | undefined;
    postWriteChangelog({ databaseChangelog, source }: {
        databaseChangelog: any;
        source: any;
    }): void;
    /**
     * @private
     * get a foreign key constraint name for tables in JHipster preferred style.
     *
     * @param {string} entityName - name of the entity
     * @param {string} relationshipName - name of the related entity
     * @param {string} prodDatabaseType - database type
     * @param {boolean} noSnakeCase - do not convert names to snakecase
     */
    getFKConstraintName(entityName: string, relationshipName: string, prodDatabaseType: string, noSnakeCase: boolean): string;
    /**
     * @private
     * get a unique constraint name for tables in JHipster preferred style.
     *
     * @param {string} entityName - name of the entity
     * @param {string} columnName - name of the column
     * @param {string} prodDatabaseType - database type
     * @param {boolean} noSnakeCase - do not convert names to snakecase
     */
    getUXConstraintName(entityName: string, columnName: string, prodDatabaseType: string, noSnakeCase: boolean): string;
}
